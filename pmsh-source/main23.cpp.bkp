#include <iostream>
#include <fstream>

using namespace std;

#include "defns5.h" 
#include <string.h> /* you need to include string to use strcmp*/

int numlevels = 0 ;
int maxbarycoord = 0 ;

char * getFileExt(int fileType) {
  if (fileType == 1)
    return "stl";
  if (fileType == 2)
    return "geo";
  else 
    return "NULL";
}

void printhelp() {
	cerr << "Invalid syntax. The parameters are: " << endl << 
		"	--stl: use stl type geometry as input. " << endl <<
        	"	--geo: use csg type geometry as input. (either geo or stl is required) " << endl <<
		"	--numprocs: number of processes (required). " << endl <<
		" 	--fineness: fineness level in netgen (required). " << endl <<
		"	--maxh: mamxh level in netgen (required). " << endl << 
		"	--outvol: if set, netgen files will be printed for each submesh. " << endl << 
		"	--outof: if set, openfoam output will be printed. " << endl <<
		"	--outgeomview: if set, geomview output will be printed. " << endl << 
		"	--help: this help will be printed. " << endl << endl <<
		"e.g. ./pmsh_netgen --stl onera-m6.stl --numcores 2048 --fineness 0.025 --maxh 0.1 --outgeomview" << endl;
}

int main (int argc, char ** argv)
{

   nglib::Ng_Mesh *mesh;             // Define pointer to a new Netgen Mesh 
   Ng_STL_Geometry *stl_geom; // Define pointer to STL Geometry
   Ng_Result ng_res;          // Result of Netgen Operations
   int  mypid      ;          // mypid 
   char geofilename[100], filename[100], filename2[100]  ;   // geometry file
   char *inpfile ;
   int    tp,ts,tv ; 
   int surf_p, surf_s, surf_v;
   int vol_p, vol_s, vol_v;
  int numlevels = -1; // -1 = error
  double fineness = -1; // -1 = error
  double maxh = -1; // -1 = error
  bool outvol = false;
  bool outgeomview = false;
  bool outof = false;
  int numprocs = 0;          // number of processors, 0 = error
  int filetype = 0; //1 = stl, 2 = geo, 0 = error
  bool error = false;

  if (argc <= 1) {
    printhelp();
    return 1;
  }

  for (int i = 1; i < argc; i++) {
    if (strcmp(argv[i], "--stl") == 0) {
      filetype = 1;
      sprintf(geofilename,"%s.stl",argv[++i])  ;
    } else  if (strcmp(argv[i], "--geo") == 0) {
      filetype = 2;
      sprintf(geofilename,"%s.geo",argv[++i])  ;
    } else  if (strcmp(argv[i], "--numprocs") == 0) { 
      numprocs = atoi(argv[++i]);
    } else  if (strcmp(argv[i], "--fineness") == 0) { 
      fineness = atof(argv[++i]);
    } else  if (strcmp(argv[i], "--maxh") == 0) { 
      maxh = atof(argv[++i]);
    } else  if (strcmp(argv[i], "--outvol") == 0) { 
      outvol = true;
    } else  if (strcmp(argv[i], "--outof") == 0) { 
      outof = true;
    } else  if (strcmp(argv[i], "--outgeomview") == 0) { 
      outgeomview = true;
    } else  if (strcmp(argv[i], "--help") == 0) { 
      printhelp();
      return 0;
    }
  }
  
// PRINT PARAMETERS
  
  cout << "The parameters are as follows: " << endl
      << "Filename: " << geofilename << endl
      << "Filetype: " << getFileExt(filetype) << endl
      << "Number of procs: " << numprocs << endl
      << "Fineness: " << fineness << ", maxh: " << maxh << endl
      << "Output: ";
  outvol ? cout << "Netgen mesh, " : 0;
  outof ? cout << "Openfoam, " : 0;
  outgeomview ? cout << "Geomview" : 0;
  cout << endl;
      
// CHECK PARAMETERS
  if (filetype == 0) {
    cerr << "ERROR: Invalid filetype." << endl;
    error = true;
  }
  
  if (numprocs <= 0) {
    cerr << "ERROR: Invalid number of processors." << endl;
    error = true;
  }
  
  if (fineness < 0) {
    cerr << "ERROR: Invalid fineness level." << endl;
    error = true;
 
  }
  
  if (maxh < 0) { 
    cerr << "ERROR: Invalid maxh level." << endl;
    error = true; 
  }
  
  if (error)
    printhelp();
    return 0;
  } 


   int *geoid;

   double t1, t2, t3, t4, tpar_, tpar;
   
   MPI_Init(&argc,&argv) ;
   MPI_Comm_rank(MPI_COMM_WORLD,&mypid);
   MPI_Comm_size(MPI_COMM_WORLD,&numprocs);
   //  mypid = 103 ; 
   
   inpfile = argv[1] ;   
   sprintf(geofilename,"%s.geo",inpfile)  ;
   numprocs = atoi(argv[2]) ; 
   
   // initialize the Netgen Core library
   Ng_Init();

   // create the mesh structure
   mesh = Ng_NewMesh();

   Ng_CSG_Geometry *geom = new Ng_CSG_Geometry(); //loaded geometry

   nglib::Ng_Meshing_Parameters mp;
   mp.maxh = atof(argv[3]) ;
   mp.fineness = atof(argv[4]) ;
   //mp.maxh = 1e6;
   //mp.fineness = 1.0 ;

   MPI_Barrier(MPI_COMM_WORLD);
   t1 = MPI_Wtime();
   ng_res = Ng_CSG_GenerateMesh (geofilename, mesh, geom, mp, nglib::MESH_SURFACE,
                                 &surf_p, &surf_s, &surf_v, geoid); //loaded geometry to geom, generated volume mesh

   ng_res = Ng_CSG_GenerateMesh (geofilename, mesh, geom, mp, nglib::MESH_VOLUME,
                                 &vol_p, &vol_s, &vol_v, geoid); //loaded geometry to geom, generated volume mesh

   if (mypid == 0) {
     printf("MY: Global coarse surface mesh - No. of P/S: %d %d\n",surf_p,surf_s) ;
   }
    
   cout << "MY: Start Volume Meshing...." << endl;

   ng_res = Ng_CSG_GenerateVolumeMesh (mesh, mp, &vol_p, &vol_s, &vol_v, geoid);

  if(ng_res != NG_OK)  {
      cout << "MY: Error in Volume Meshing....Aborting!!" << endl;
        return 1;
   }

   numlevels = atoi(argv[5]) ;
    maxbarycoord =  1  ;
    maxbarycoord =  1  << numlevels ;

   // Barrier 
   //timer serial finish 

   sprintf(filename, "mesh.init");
   //My_Ng_Export_OF (mesh, geofilename, filename);

   //if (mypid == 0) { 
   //  printf("MY: Global coarse volume mesh - No. of P/S/V: %d %d %d\n",vol_p,vol_s,vol_v) ; 
   //}
  
   MPI_Barrier(MPI_COMM_WORLD);
   t2 = MPI_Wtime();
   
   nglib::Ng_Mesh *submesh ;
   submesh = Ng_NewMesh();
   
   if (0) {  
     pSortedKey keys ;
     int numkeys ;
     int indx[numprocs+1] ;
     compute_keys(mesh,&numkeys,&keys) ;
     seq_rec_subdiv(0,numprocs-1,0,numkeys-1,indx,keys) ;
     indx[numprocs] = numkeys ; 
     //printf("MY: Partitioning complete:  numprocs: %d\nMY:",numprocs) ; 
     //for(int k=0 ; k <= numprocs ; k++) printf(" %d ",indx[k]) ; 
     //printf("\n") ;
     cre_part_surf_mesh(mesh,numprocs,mypid,indx,keys,submesh) ;
   } 
   else {
      partwmetis(mesh,numprocs) ; 
      cre_part_surf_mesh(mesh,numprocs,mypid,submesh) ;
   }

   printf("MY: [%2d] Submeshes creation complete..\n",mypid) ;
   unirefine(submesh,numlevels) ; 
   computeadj(mypid) ;

   printf("MY: [%2d] Refinement complete..\n",mypid);

   sprintf(filename,"%s.%d.vol",inpfile,mypid) ;
   //printf("MY: [%2d] Saving Mesh in VOL Format\n",mypid);
   //Ng_SaveMesh(submesh,filename);
   //exit(0);
   unsigned long int tpsc[3], psc2[3];
   int psc[3];
   psc[0]=psc[1]=psc[2]=0 ;
   tpsc[0]=tpsc[1]=tpsc[2]=0 ;
   Ng_DeleteMesh (mesh) ;  // NNN

   //sprintf(filename,"%s.%d.vol",inpfile,mypid) ;
   //printf("MY: [%2d] Saving Mesh in VOL Format\n",mypid);
   //Ng_SaveMesh(submesh,filename);

   //outgeomview(mypid,numprocs,submesh,inpfile) ;
   // tetgen call

#ifdef TETGEN
   tetgenio in, out;
   sprintf(filename,"%s.%d",inpfile,mypid);
   sprintf(filename2,"%s.%d.off",inpfile,mypid);
   in.load_off(filename2);
   tetrahedralize("pqYNEFO", &in, NULL, filename);
   // read number from output.off file to psc[0], psc[1], psc[2]
   // ???
#endif

#ifdef NETGEN
   mp.fineness = atof(argv[4]) ;
   mp.maxh = atof(argv[3]) ;
   mp.second_order = 0; 

   ng_res = Ng_CSG_GenerateVolumeMesh (submesh, mp, &psc[0], &psc[1], &psc[2], geoid);

   //sprintf(filename,"%s.%d.vol",inpfile,mypid) ;
   //printf("MY: [%4d] Saving Mesh in VOL Format\n",mypid);
   //Ng_SaveMesh(submesh,filename);

#endif

   // Barrier
   //timer parallel finish 
   MPI_Barrier(MPI_COMM_WORLD);
   t3 = MPI_Wtime();

   //outgeomview(mypid,numprocs,submesh,inpfile) ;
#ifdef EXPORT
   sprintf(filename, "processor%d",mypid);
   My_Ng_Export_OF (submesh, geofilename, filename);
#endif

   printf("MY: [%4d] No. of P/S/V: %d %d %d\n",mypid,psc[0],psc[1],psc[2]) ;
   psc2[0] = psc[0];
   psc2[1] = psc[1];
   psc2[2] = psc[2];
   MPI_Reduce(psc2,tpsc,3,MPI_UNSIGNED_LONG,MPI_SUM,0,MPI_COMM_WORLD) ; 
   if (mypid == 0) {
      printf("MY: Total No. of P/S/V: %lu %lu %lu\n",tpsc[0],tpsc[1],tpsc[2]) ;
   } 

   verifysubmesh(mesh,submesh,mypid) ;

#ifdef DEBUG
   outbaryc(submesh,mypid);
#endif

   com_barycoords(submesh,MPI_COMM_WORLD,numprocs,mypid) ;

   if (mypid == 0) {
      printf("RESULT: %s %d %d %.3f %.3f %d %d %d %d %lu %lu %lu %.2f %.2f\n",
                inpfile, numprocs, numprocs, mp.maxh, mp.fineness, numlevels,
                surf_p, surf_s, vol_v, // after surf & after volume mesh
                tpsc[0], tpsc[1], tpsc[2],
                t2-t1, t3-t2); // after refinement
   }

   MPI_Finalize() ;
   exit(0) ;   
}

